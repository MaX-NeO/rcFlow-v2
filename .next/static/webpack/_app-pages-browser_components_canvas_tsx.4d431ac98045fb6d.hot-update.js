"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_components_canvas_tsx",{

/***/ "(app-pages-browser)/./components/canvas.tsx":
/*!*******************************!*\
  !*** ./components/canvas.tsx ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var reactflow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! reactflow */ \"(app-pages-browser)/./node_modules/@reactflow/core/dist/esm/index.mjs\");\n/* harmony import */ var reactflow__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! reactflow */ \"(app-pages-browser)/./node_modules/@reactflow/controls/dist/esm/index.mjs\");\n/* harmony import */ var reactflow_dist_style_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! reactflow/dist/style.css */ \"(app-pages-browser)/./node_modules/reactflow/dist/style.css\");\n/* harmony import */ var _lib_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/store */ \"(app-pages-browser)/./lib/store.ts\");\n/* harmony import */ var _nodes_custom_node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nodes/custom-node */ \"(app-pages-browser)/./components/nodes/custom-node.tsx\");\n/* harmony import */ var _toolbar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./toolbar */ \"(app-pages-browser)/./components/toolbar.tsx\");\n/* __next_internal_client_entry_do_not_use__ Canvas auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst nodeTypes = {\n    custom: _nodes_custom_node__WEBPACK_IMPORTED_MODULE_4__.CustomNode\n};\nfunction FlowCanvas() {\n    _s();\n    const reactFlowWrapper = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { currentTool, setCurrentTool, nodes, edges, setNodes, setEdges, saveToHistory, undo, selectedNodes, setSelectedNodes, clipboard, setClipboard } = (0,_lib_store__WEBPACK_IMPORTED_MODULE_3__.useAppStore)();\n    const { project } = (0,reactflow__WEBPACK_IMPORTED_MODULE_6__.useReactFlow)();\n    // Generate unique ID for new nodes\n    const generateNodeId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[generateNodeId]\": ()=>\"node-\".concat(Date.now(), \"-\").concat(Math.random())\n    }[\"FlowCanvas.useCallback[generateNodeId]\"], []);\n    const generateEdgeId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[generateEdgeId]\": ()=>\"edge-\".concat(Date.now(), \"-\").concat(Math.random())\n    }[\"FlowCanvas.useCallback[generateEdgeId]\"], []);\n    // Keyboard shortcuts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"FlowCanvas.useEffect\": ()=>{\n            const handleKeyDown = {\n                \"FlowCanvas.useEffect.handleKeyDown\": (event)=>{\n                    // Copy (Ctrl+C)\n                    if (event.ctrlKey && event.key === 'c') {\n                        event.preventDefault();\n                        if (selectedNodes.length > 0) {\n                            const selectedNodeIds = selectedNodes.map({\n                                \"FlowCanvas.useEffect.handleKeyDown.selectedNodeIds\": (node)=>node.id\n                            }[\"FlowCanvas.useEffect.handleKeyDown.selectedNodeIds\"]);\n                            const selectedEdges = edges.filter({\n                                \"FlowCanvas.useEffect.handleKeyDown.selectedEdges\": (edge)=>selectedNodeIds.includes(edge.source) && selectedNodeIds.includes(edge.target)\n                            }[\"FlowCanvas.useEffect.handleKeyDown.selectedEdges\"]);\n                            setClipboard({\n                                nodes: selectedNodes,\n                                edges: selectedEdges\n                            });\n                        }\n                    }\n                    // Paste (Ctrl+V)\n                    if (event.ctrlKey && event.key === 'v') {\n                        event.preventDefault();\n                        if (clipboard) {\n                            const nodeIdMap = new Map();\n                            const newNodes = clipboard.nodes.map({\n                                \"FlowCanvas.useEffect.handleKeyDown.newNodes\": (node)=>{\n                                    const newId = generateNodeId();\n                                    nodeIdMap.set(node.id, newId);\n                                    return {\n                                        ...node,\n                                        id: newId,\n                                        position: {\n                                            x: node.position.x + 50,\n                                            y: node.position.y + 50\n                                        },\n                                        selected: false\n                                    };\n                                }\n                            }[\"FlowCanvas.useEffect.handleKeyDown.newNodes\"]);\n                            const newEdges = clipboard.edges.map({\n                                \"FlowCanvas.useEffect.handleKeyDown.newEdges\": (edge)=>({\n                                        ...edge,\n                                        id: generateEdgeId(),\n                                        source: nodeIdMap.get(edge.source),\n                                        target: nodeIdMap.get(edge.target)\n                                    })\n                            }[\"FlowCanvas.useEffect.handleKeyDown.newEdges\"]);\n                            setNodes([\n                                ...nodes,\n                                ...newNodes\n                            ]);\n                            setEdges([\n                                ...edges,\n                                ...newEdges\n                            ]);\n                            saveToHistory();\n                        }\n                    }\n                    // Delete (Del)\n                    if (event.key === 'Delete') {\n                        event.preventDefault();\n                        if (selectedNodes.length > 0) {\n                            const selectedNodeIds = selectedNodes.map({\n                                \"FlowCanvas.useEffect.handleKeyDown.selectedNodeIds\": (node)=>node.id\n                            }[\"FlowCanvas.useEffect.handleKeyDown.selectedNodeIds\"]);\n                            setNodes(nodes.filter({\n                                \"FlowCanvas.useEffect.handleKeyDown\": (node)=>!selectedNodeIds.includes(node.id)\n                            }[\"FlowCanvas.useEffect.handleKeyDown\"]));\n                            setEdges(edges.filter({\n                                \"FlowCanvas.useEffect.handleKeyDown\": (edge)=>!selectedNodeIds.includes(edge.source) && !selectedNodeIds.includes(edge.target)\n                            }[\"FlowCanvas.useEffect.handleKeyDown\"]));\n                            setSelectedNodes([]);\n                            saveToHistory();\n                        }\n                    }\n                    // Undo (Ctrl+Z)\n                    if (event.ctrlKey && event.key === 'z') {\n                        event.preventDefault();\n                        undo();\n                    }\n                }\n            }[\"FlowCanvas.useEffect.handleKeyDown\"];\n            document.addEventListener('keydown', handleKeyDown);\n            return ({\n                \"FlowCanvas.useEffect\": ()=>document.removeEventListener('keydown', handleKeyDown)\n            })[\"FlowCanvas.useEffect\"];\n        }\n    }[\"FlowCanvas.useEffect\"], [\n        selectedNodes,\n        nodes,\n        edges,\n        clipboard,\n        setNodes,\n        setEdges,\n        setSelectedNodes,\n        setClipboard,\n        saveToHistory,\n        undo,\n        generateNodeId,\n        generateEdgeId\n    ]);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[onNodesChange]\": (changes)=>{\n            setNodes((0,reactflow__WEBPACK_IMPORTED_MODULE_6__.applyNodeChanges)(changes, nodes));\n        }\n    }[\"FlowCanvas.useCallback[onNodesChange]\"], [\n        nodes,\n        setNodes\n    ]);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[onEdgesChange]\": (changes)=>{\n            setEdges((0,reactflow__WEBPACK_IMPORTED_MODULE_6__.applyEdgeChanges)(changes, edges));\n        }\n    }[\"FlowCanvas.useCallback[onEdgesChange]\"], [\n        edges,\n        setEdges\n    ]);\n    const onConnect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[onConnect]\": (params)=>{\n            const newEdge = {\n                id: generateEdgeId(),\n                ...params,\n                style: {\n                    stroke: '#8b5cf6',\n                    strokeWidth: 2\n                },\n                markerEnd: {\n                    type: reactflow__WEBPACK_IMPORTED_MODULE_6__.MarkerType.ArrowClosed,\n                    width: 10,\n                    height: 10,\n                    color: '#8b5cf6'\n                },\n                animated: true\n            };\n            setEdges((0,reactflow__WEBPACK_IMPORTED_MODULE_6__.addEdge)(newEdge, edges));\n            saveToHistory();\n            // Update handle positions after connection\n            setTimeout({\n                \"FlowCanvas.useCallback[onConnect]\": ()=>{\n                    updateHandlePositions();\n                }\n            }[\"FlowCanvas.useCallback[onConnect]\"], 100);\n        }\n    }[\"FlowCanvas.useCallback[onConnect]\"], [\n        edges,\n        setEdges,\n        saveToHistory,\n        generateEdgeId\n    ]);\n    const onPaneClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[onPaneClick]\": (event)=>{\n            var _reactFlowWrapper_current;\n            // Close any open popups and editing state when clicking on empty canvas\n            const state = _lib_store__WEBPACK_IMPORTED_MODULE_3__.useAppStore.getState();\n            state.setEditingNodeId(null);\n            // Force close all popups by triggering a global popup close event\n            const popupCloseEvent = new CustomEvent('closeAllPopups');\n            document.dispatchEvent(popupCloseEvent);\n            if (currentTool === 'select') return;\n            const bounds = (_reactFlowWrapper_current = reactFlowWrapper.current) === null || _reactFlowWrapper_current === void 0 ? void 0 : _reactFlowWrapper_current.getBoundingClientRect();\n            if (!bounds) return;\n            const position = project({\n                x: event.clientX - bounds.left,\n                y: event.clientY - bounds.top\n            });\n            const newNode = {\n                id: generateNodeId(),\n                type: 'custom',\n                position,\n                data: {\n                    label: '',\n                    nodeType: currentTool === 'label' ? 'label' : currentTool,\n                    width: currentTool === 'label' ? 80 : currentTool === 'circle' ? 80 : 90,\n                    height: currentTool === 'label' ? 30 : currentTool === 'circle' ? 80 : 60,\n                    backgroundColor: undefined,\n                    textColor: undefined,\n                    borderStyle: 'solid'\n                }\n            };\n            setNodes([\n                ...nodes,\n                newNode\n            ]);\n            saveToHistory();\n            // Auto-switch back to select mode after creating a shape\n            setCurrentTool('select');\n        }\n    }[\"FlowCanvas.useCallback[onPaneClick]\"], [\n        currentTool,\n        project,\n        nodes,\n        setNodes,\n        saveToHistory,\n        setCurrentTool,\n        generateNodeId\n    ]);\n    const onSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[onSelectionChange]\": (params)=>{\n            setSelectedNodes(params.nodes);\n        }\n    }[\"FlowCanvas.useCallback[onSelectionChange]\"], [\n        setSelectedNodes\n    ]);\n    const onNodeClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[onNodeClick]\": (event, node)=>{\n            event.stopPropagation();\n        // Allow the node's own click handler to manage popup state\n        }\n    }[\"FlowCanvas.useCallback[onNodeClick]\"], []);\n    const onEdgeClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[onEdgeClick]\": (event, edge)=>{}\n    }[\"FlowCanvas.useCallback[onEdgeClick]\"], []);\n    const onNodeDragStop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[onNodeDragStop]\": ()=>{\n            saveToHistory();\n        }\n    }[\"FlowCanvas.useCallback[onNodeDragStop]\"], [\n        saveToHistory\n    ]);\n    // Function to update handle positions based on node relationships\n    const updateHandlePositions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[updateHandlePositions]\": ()=>{\n            const updatedNodes = nodes.map({\n                \"FlowCanvas.useCallback[updateHandlePositions].updatedNodes\": (node)=>{\n                    // Find all edges connected to this node\n                    const connectedEdges = edges.filter({\n                        \"FlowCanvas.useCallback[updateHandlePositions].updatedNodes.connectedEdges\": (edge)=>edge.source === node.id || edge.target === node.id\n                    }[\"FlowCanvas.useCallback[updateHandlePositions].updatedNodes.connectedEdges\"]);\n                    // Calculate optimal handle positions based on connected nodes\n                    const handlePositions = calculateOptimalHandles(node, connectedEdges, nodes);\n                    return {\n                        ...node,\n                        data: {\n                            ...node.data,\n                            handlePositions\n                        }\n                    };\n                }\n            }[\"FlowCanvas.useCallback[updateHandlePositions].updatedNodes\"]);\n            setNodes(updatedNodes);\n        }\n    }[\"FlowCanvas.useCallback[updateHandlePositions]\"], [\n        nodes,\n        edges,\n        setNodes\n    ]);\n    // Helper function to calculate optimal handle positions\n    const calculateOptimalHandles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FlowCanvas.useCallback[calculateOptimalHandles]\": (node, connectedEdges, allNodes)=>{\n            const handles = {};\n            connectedEdges.forEach({\n                \"FlowCanvas.useCallback[calculateOptimalHandles]\": (edge)=>{\n                    const isSource = edge.source === node.id;\n                    const connectedNodeId = isSource ? edge.target : edge.source;\n                    const connectedNode = allNodes.find({\n                        \"FlowCanvas.useCallback[calculateOptimalHandles].connectedNode\": (n)=>n.id === connectedNodeId\n                    }[\"FlowCanvas.useCallback[calculateOptimalHandles].connectedNode\"]);\n                    if (connectedNode) {\n                        const dx = connectedNode.position.x - node.position.x;\n                        const dy = connectedNode.position.y - node.position.y;\n                        // Determine the best handle position based on relative position\n                        let position;\n                        if (Math.abs(dx) > Math.abs(dy)) {\n                            // Horizontal connection is stronger\n                            position = dx > 0 ? Position.Right : Position.Left;\n                        } else {\n                            // Vertical connection is stronger\n                            position = dy > 0 ? Position.Bottom : Position.Top;\n                        }\n                        const handleType = isSource ? 'source' : 'target';\n                        handles[\"\".concat(handleType, \"-\").concat(edge.id)] = position;\n                    }\n                }\n            }[\"FlowCanvas.useCallback[calculateOptimalHandles]\"]);\n            return handles;\n        }\n    }[\"FlowCanvas.useCallback[calculateOptimalHandles]\"], []);\n    // Custom node types with layout-aware handles\n    const nodeTypes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"FlowCanvas.useMemo[nodeTypes]\": ()=>({\n                custom: ({\n                    \"FlowCanvas.useMemo[nodeTypes]\": (props)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_nodes_custom_node__WEBPACK_IMPORTED_MODULE_4__.CustomNode, {\n                            ...props\n                        }, void 0, false, {\n                            fileName: \"/home/project/components/canvas.tsx\",\n                            lineNumber: 290,\n                            columnNumber: 29\n                        }, this)\n                })[\"FlowCanvas.useMemo[nodeTypes]\"]\n            })\n    }[\"FlowCanvas.useMemo[nodeTypes]\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full h-full\",\n        ref: reactFlowWrapper,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(reactflow__WEBPACK_IMPORTED_MODULE_6__.ReactFlow, {\n            nodes: nodes,\n            edges: edges,\n            onNodesChange: onNodesChange,\n            onEdgesChange: onEdgesChange,\n            onConnect: onConnect,\n            onPaneClick: onPaneClick,\n            onNodeClick: onNodeClick,\n            onEdgeClick: onEdgeClick,\n            onNodeDragStop: onNodeDragStop,\n            onSelectionChange: onSelectionChange,\n            nodeTypes: nodeTypes,\n            fitView: true,\n            className: \"bg-gray-50 dark:bg-[#0a0a0a]\",\n            nodesDraggable: currentTool === 'select',\n            nodesConnectable: currentTool === 'select',\n            elementsSelectable: currentTool === 'select',\n            panOnDrag: currentTool === 'select',\n            zoomOnScroll: currentTool === 'select',\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(reactflow__WEBPACK_IMPORTED_MODULE_7__.Controls, {\n                position: \"bottom-right\",\n                className: \"bg-white dark:bg-[#101010] border border-gray-200 dark:border-gray-700\"\n            }, void 0, false, {\n                fileName: \"/home/project/components/canvas.tsx\",\n                lineNumber: 316,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/home/project/components/canvas.tsx\",\n            lineNumber: 295,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/home/project/components/canvas.tsx\",\n        lineNumber: 294,\n        columnNumber: 5\n    }, this);\n}\n_s(FlowCanvas, \"xVCOGhKiVhqXkjCQUEfUE4670yg=\", false, function() {\n    return [\n        _lib_store__WEBPACK_IMPORTED_MODULE_3__.useAppStore,\n        reactflow__WEBPACK_IMPORTED_MODULE_6__.useReactFlow\n    ];\n});\n_c = FlowCanvas;\nfunction Canvas() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(reactflow__WEBPACK_IMPORTED_MODULE_6__.ReactFlowProvider, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_toolbar__WEBPACK_IMPORTED_MODULE_5__.Toolbar, {}, void 0, false, {\n                fileName: \"/home/project/components/canvas.tsx\",\n                lineNumber: 328,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(FlowCanvas, {}, void 0, false, {\n                fileName: \"/home/project/components/canvas.tsx\",\n                lineNumber: 329,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/project/components/canvas.tsx\",\n        lineNumber: 327,\n        columnNumber: 5\n    }, this);\n}\n_c1 = Canvas;\nvar _c, _c1;\n$RefreshReg$(_c, \"FlowCanvas\");\n$RefreshReg$(_c1, \"Canvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY2FudmFzLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFFZ0U7QUFnQjdDO0FBQ2U7QUFDUTtBQUNPO0FBQ2I7QUFFcEMsTUFBTWUsWUFBWTtJQUNoQkMsUUFBUUgsMERBQVVBO0FBQ3BCO0FBRUEsU0FBU0k7O0lBQ1AsTUFBTUMsbUJBQW1CakIsNkNBQU1BLENBQWlCO0lBQ2hELE1BQU0sRUFDSmtCLFdBQVcsRUFDWEMsY0FBYyxFQUNkQyxLQUFLLEVBQ0xDLEtBQUssRUFDTEMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLGFBQWEsRUFDYkMsSUFBSSxFQUNKQyxhQUFhLEVBQ2JDLGdCQUFnQixFQUNoQkMsU0FBUyxFQUNUQyxZQUFZLEVBQ2IsR0FBR2xCLHVEQUFXQTtJQUVmLE1BQU0sRUFBRW1CLE9BQU8sRUFBRSxHQUFHckIsdURBQVlBO0lBRWhDLG1DQUFtQztJQUNuQyxNQUFNc0IsaUJBQWlCaEMsa0RBQVdBO2tEQUFDLElBQU0sUUFBc0JpQyxPQUFkQyxLQUFLQyxHQUFHLElBQUcsS0FBaUIsT0FBZEYsS0FBS0csTUFBTTtpREFBTSxFQUFFO0lBQ2xGLE1BQU1DLGlCQUFpQnJDLGtEQUFXQTtrREFBQyxJQUFNLFFBQXNCaUMsT0FBZEMsS0FBS0MsR0FBRyxJQUFHLEtBQWlCLE9BQWRGLEtBQUtHLE1BQU07aURBQU0sRUFBRTtJQUVsRixxQkFBcUI7SUFDckJsQyxnREFBU0E7Z0NBQUM7WUFDUixNQUFNb0M7c0RBQWdCLENBQUNDO29CQUNyQixnQkFBZ0I7b0JBQ2hCLElBQUlBLE1BQU1DLE9BQU8sSUFBSUQsTUFBTUUsR0FBRyxLQUFLLEtBQUs7d0JBQ3RDRixNQUFNRyxjQUFjO3dCQUNwQixJQUFJZixjQUFjZ0IsTUFBTSxHQUFHLEdBQUc7NEJBQzVCLE1BQU1DLGtCQUFrQmpCLGNBQWNrQixHQUFHO3NGQUFDQyxDQUFBQSxPQUFRQSxLQUFLQyxFQUFFOzs0QkFDekQsTUFBTUMsZ0JB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O1lBRUEsT0FBTzJEO1FBQ1Q7MERBQUcsRUFBRTtJQUNMLDhDQUE4QztJQUM5QyxNQUFNdkcsWUFBWVosOENBQU9BO3lDQUFDLElBQU87Z0JBQy9CYSxNQUFNO3FEQUFFLENBQUNzSCxzQkFBZSw4REFBQ3pILDBEQUFVQTs0QkFBRSxHQUFHeUgsS0FBSzs7Ozs7OztZQUMvQzt3Q0FBSSxFQUFFO0lBRU4scUJBQ0UsOERBQUNDO1FBQUlDLFdBQVU7UUFBZ0JDLEtBQUt2SDtrQkFDbEMsNEVBQUNkLGdEQUFTQTtZQUNSaUIsT0FBT0E7WUFDUEMsT0FBT0E7WUFDUDhDLGVBQWVBO1lBQ2ZFLGVBQWVBO1lBQ2ZDLFdBQVdBO1lBQ1hlLGFBQWFBO1lBQ2J1QixhQUFhQTtZQUNiRSxhQUFhQTtZQUNiQyxnQkFBZ0JBO1lBQ2hCSixtQkFBbUJBO1lBQ25CN0YsV0FBV0E7WUFDWDJILE9BQU87WUFDUEYsV0FBVTtZQUNWRyxnQkFBZ0J4SCxnQkFBZ0I7WUFDaEN5SCxrQkFBa0J6SCxnQkFBZ0I7WUFDbEMwSCxvQkFBb0IxSCxnQkFBZ0I7WUFDcEMySCxXQUFXM0gsZ0JBQWdCO1lBQzNCNEgsY0FBYzVILGdCQUFnQjtzQkFHOUIsNEVBQUNWLCtDQUFRQTtnQkFDUGtELFVBQVM7Z0JBQ1Q2RSxXQUFVOzs7Ozs7Ozs7Ozs7Ozs7O0FBS3BCO0dBdFNTdkg7O1FBZUhMLG1EQUFXQTtRQUVLRixtREFBWUE7OztLQWpCekJPO0FBd1NGLFNBQVMrSDtJQUNkLHFCQUNFLDhEQUFDM0ksd0RBQWlCQTs7MEJBQ2hCLDhEQUFDUyw2Q0FBT0E7Ozs7OzBCQUNSLDhEQUFDRzs7Ozs7Ozs7Ozs7QUFHUDtNQVBnQitIIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L2NvbXBvbmVudHMvY2FudmFzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0Rmxvdywge1xuICBSZWFjdEZsb3dQcm92aWRlcixcbiAgYWRkRWRnZSxcbiAgQ29ubmVjdGlvbixcbiAgRWRnZSxcbiAgTm9kZSxcbiAgYXBwbHlOb2RlQ2hhbmdlcyxcbiAgYXBwbHlFZGdlQ2hhbmdlcyxcbiAgTm9kZUNoYW5nZSxcbiAgRWRnZUNoYW5nZSxcbiAgQ29udHJvbHMsXG4gIEJhY2tncm91bmQsXG4gIHVzZVJlYWN0RmxvdyxcbiAgT25TZWxlY3Rpb25DaGFuZ2VQYXJhbXMsXG4gIE1hcmtlclR5cGUsXG59IGZyb20gJ3JlYWN0Zmxvdyc7XG5pbXBvcnQgJ3JlYWN0Zmxvdy9kaXN0L3N0eWxlLmNzcyc7XG5pbXBvcnQgeyB1c2VBcHBTdG9yZSB9IGZyb20gJ0AvbGliL3N0b3JlJztcbmltcG9ydCB7IEN1c3RvbU5vZGUgfSBmcm9tICcuL25vZGVzL2N1c3RvbS1ub2RlJztcbmltcG9ydCB7IFRvb2xiYXIgfSBmcm9tICcuL3Rvb2xiYXInO1xuXG5jb25zdCBub2RlVHlwZXMgPSB7XG4gIGN1c3RvbTogQ3VzdG9tTm9kZSxcbn07XG5cbmZ1bmN0aW9uIEZsb3dDYW52YXMoKSB7XG4gIGNvbnN0IHJlYWN0Rmxvd1dyYXBwZXIgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCB7XG4gICAgY3VycmVudFRvb2wsXG4gICAgc2V0Q3VycmVudFRvb2wsXG4gICAgbm9kZXMsXG4gICAgZWRnZXMsXG4gICAgc2V0Tm9kZXMsXG4gICAgc2V0RWRnZXMsXG4gICAgc2F2ZVRvSGlzdG9yeSxcbiAgICB1bmRvLFxuICAgIHNlbGVjdGVkTm9kZXMsXG4gICAgc2V0U2VsZWN0ZWROb2RlcyxcbiAgICBjbGlwYm9hcmQsXG4gICAgc2V0Q2xpcGJvYXJkLFxuICB9ID0gdXNlQXBwU3RvcmUoKTtcblxuICBjb25zdCB7IHByb2plY3QgfSA9IHVzZVJlYWN0RmxvdygpO1xuXG4gIC8vIEdlbmVyYXRlIHVuaXF1ZSBJRCBmb3IgbmV3IG5vZGVzXG4gIGNvbnN0IGdlbmVyYXRlTm9kZUlkID0gdXNlQ2FsbGJhY2soKCkgPT4gYG5vZGUtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCl9YCwgW10pO1xuICBjb25zdCBnZW5lcmF0ZUVkZ2VJZCA9IHVzZUNhbGxiYWNrKCgpID0+IGBlZGdlLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpfWAsIFtdKTtcblxuICAvLyBLZXlib2FyZCBzaG9ydGN1dHNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAvLyBDb3B5IChDdHJsK0MpXG4gICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXkgPT09ICdjJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoc2VsZWN0ZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlSWRzID0gc2VsZWN0ZWROb2Rlcy5tYXAobm9kZSA9PiBub2RlLmlkKTtcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZEVkZ2VzID0gZWRnZXMuZmlsdGVyKGVkZ2UgPT4gXG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVJZHMuaW5jbHVkZXMoZWRnZS5zb3VyY2UpICYmIHNlbGVjdGVkTm9kZUlkcy5pbmNsdWRlcyhlZGdlLnRhcmdldClcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldENsaXBib2FyZCh7IG5vZGVzOiBzZWxlY3RlZE5vZGVzLCBlZGdlczogc2VsZWN0ZWRFZGdlcyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBQYXN0ZSAoQ3RybCtWKVxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQua2V5ID09PSAndicpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGNsaXBib2FyZCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVJZE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBjb25zdCBuZXdOb2RlcyA9IGNsaXBib2FyZC5ub2Rlcy5tYXAobm9kZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJZCA9IGdlbmVyYXRlTm9kZUlkKCk7XG4gICAgICAgICAgICBub2RlSWRNYXAuc2V0KG5vZGUuaWQsIG5ld0lkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgIGlkOiBuZXdJZCxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBub2RlLnBvc2l0aW9uLnggKyA1MCxcbiAgICAgICAgICAgICAgICB5OiBub2RlLnBvc2l0aW9uLnkgKyA1MCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBuZXdFZGdlcyA9IGNsaXBib2FyZC5lZGdlcy5tYXAoZWRnZSA9PiAoe1xuICAgICAgICAgICAgLi4uZWRnZSxcbiAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUVkZ2VJZCgpLFxuICAgICAgICAgICAgc291cmNlOiBub2RlSWRNYXAuZ2V0KGVkZ2Uuc291cmNlKSxcbiAgICAgICAgICAgIHRhcmdldDogbm9kZUlkTWFwLmdldChlZGdlLnRhcmdldCksXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldE5vZGVzKFsuLi5ub2RlcywgLi4ubmV3Tm9kZXNdKTtcbiAgICAgICAgICBzZXRFZGdlcyhbLi4uZWRnZXMsIC4uLm5ld0VkZ2VzXSk7XG4gICAgICAgICAgc2F2ZVRvSGlzdG9yeSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERlbGV0ZSAoRGVsKVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0RlbGV0ZScpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZUlkcyA9IHNlbGVjdGVkTm9kZXMubWFwKG5vZGUgPT4gbm9kZS5pZCk7XG4gICAgICAgICAgc2V0Tm9kZXMobm9kZXMuZmlsdGVyKG5vZGUgPT4gIXNlbGVjdGVkTm9kZUlkcy5pbmNsdWRlcyhub2RlLmlkKSkpO1xuICAgICAgICAgIHNldEVkZ2VzKGVkZ2VzLmZpbHRlcihlZGdlID0+IFxuICAgICAgICAgICAgIXNlbGVjdGVkTm9kZUlkcy5pbmNsdWRlcyhlZGdlLnNvdXJjZSkgJiYgIXNlbGVjdGVkTm9kZUlkcy5pbmNsdWRlcyhlZGdlLnRhcmdldClcbiAgICAgICAgICApKTtcbiAgICAgICAgICBzZXRTZWxlY3RlZE5vZGVzKFtdKTtcbiAgICAgICAgICBzYXZlVG9IaXN0b3J5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVW5kbyAoQ3RybCtaKVxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQua2V5ID09PSAneicpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdW5kbygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG4gICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgfSwgW3NlbGVjdGVkTm9kZXMsIG5vZGVzLCBlZGdlcywgY2xpcGJvYXJkLCBzZXROb2Rlcywgc2V0RWRnZXMsIHNldFNlbGVjdGVkTm9kZXMsIHNldENsaXBib2FyZCwgc2F2ZVRvSGlzdG9yeSwgdW5kbywgZ2VuZXJhdGVOb2RlSWQsIGdlbmVyYXRlRWRnZUlkXSk7XG5cbiAgY29uc3Qgb25Ob2Rlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIChjaGFuZ2VzOiBOb2RlQ2hhbmdlW10pID0+IHtcbiAgICAgIHNldE5vZGVzKGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpKTtcbiAgICB9LFxuICAgIFtub2Rlcywgc2V0Tm9kZXNdXG4gICk7XG5cbiAgY29uc3Qgb25FZGdlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIChjaGFuZ2VzOiBFZGdlQ2hhbmdlW10pID0+IHtcbiAgICAgIHNldEVkZ2VzKGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpKTtcbiAgICB9LFxuICAgIFtlZGdlcywgc2V0RWRnZXNdXG4gICk7XG5cbiAgY29uc3Qgb25Db25uZWN0ID0gdXNlQ2FsbGJhY2soXG4gICAgKHBhcmFtczogQ29ubmVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgbmV3RWRnZSA9IHsgXG4gICAgICAgIGlkOiBnZW5lcmF0ZUVkZ2VJZCgpLFxuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHN0eWxlOiB7IFxuICAgICAgICAgIHN0cm9rZTogJyM4YjVjZjYnLCBcbiAgICAgICAgICBzdHJva2VXaWR0aDogMiBcbiAgICAgICAgfSxcbiAgICAgICAgbWFya2VyRW5kOiB7XG4gICAgICAgICAgdHlwZTogTWFya2VyVHlwZS5BcnJvd0Nsb3NlZCxcbiAgICAgICAgICB3aWR0aDogMTAsXG4gICAgICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgICAgICBjb2xvcjogJyM4YjVjZjYnLFxuICAgICAgICB9LFxuICAgICAgICBhbmltYXRlZDogdHJ1ZSxcbiAgICAgIH07XG4gICAgICBzZXRFZGdlcyhhZGRFZGdlKG5ld0VkZ2UsIGVkZ2VzKSk7XG4gICAgICBzYXZlVG9IaXN0b3J5KCk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBoYW5kbGUgcG9zaXRpb25zIGFmdGVyIGNvbm5lY3Rpb25cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB1cGRhdGVIYW5kbGVQb3NpdGlvbnMoKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSxcbiAgICBbZWRnZXMsIHNldEVkZ2VzLCBzYXZlVG9IaXN0b3J5LCBnZW5lcmF0ZUVkZ2VJZF1cbiAgKTtcblxuICBjb25zdCBvblBhbmVDbGljayA9IHVzZUNhbGxiYWNrKFxuICAgIChldmVudDogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgLy8gQ2xvc2UgYW55IG9wZW4gcG9wdXBzIGFuZCBlZGl0aW5nIHN0YXRlIHdoZW4gY2xpY2tpbmcgb24gZW1wdHkgY2FudmFzXG4gICAgICBjb25zdCBzdGF0ZSA9IHVzZUFwcFN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBzdGF0ZS5zZXRFZGl0aW5nTm9kZUlkKG51bGwpO1xuICAgICAgXG4gICAgICAvLyBGb3JjZSBjbG9zZSBhbGwgcG9wdXBzIGJ5IHRyaWdnZXJpbmcgYSBnbG9iYWwgcG9wdXAgY2xvc2UgZXZlbnRcbiAgICAgIGNvbnN0IHBvcHVwQ2xvc2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2xvc2VBbGxQb3B1cHMnKTtcbiAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQocG9wdXBDbG9zZUV2ZW50KTtcbiAgICAgIFxuICAgICAgaWYgKGN1cnJlbnRUb29sID09PSAnc2VsZWN0JykgcmV0dXJuO1xuXG4gICAgICBjb25zdCBib3VuZHMgPSByZWFjdEZsb3dXcmFwcGVyLmN1cnJlbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKCFib3VuZHMpIHJldHVybjtcblxuICAgICAgY29uc3QgcG9zaXRpb24gPSBwcm9qZWN0KHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCAtIGJvdW5kcy5sZWZ0LFxuICAgICAgICB5OiBldmVudC5jbGllbnRZIC0gYm91bmRzLnRvcCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBuZXdOb2RlOiBOb2RlID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVOb2RlSWQoKSxcbiAgICAgICAgdHlwZTogJ2N1c3RvbScsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgIG5vZGVUeXBlOiBjdXJyZW50VG9vbCA9PT0gJ2xhYmVsJyA/ICdsYWJlbCcgOiBjdXJyZW50VG9vbCxcbiAgICAgICAgICB3aWR0aDogY3VycmVudFRvb2wgPT09ICdsYWJlbCcgPyA4MCA6IGN1cnJlbnRUb29sID09PSAnY2lyY2xlJyA/IDgwIDogOTAsXG4gICAgICAgICAgaGVpZ2h0OiBjdXJyZW50VG9vbCA9PT0gJ2xhYmVsJyA/IDMwIDogY3VycmVudFRvb2wgPT09ICdjaXJjbGUnID8gODAgOiA2MCxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICB0ZXh0Q29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHNldE5vZGVzKFsuLi5ub2RlcywgbmV3Tm9kZV0pO1xuICAgICAgc2F2ZVRvSGlzdG9yeSgpO1xuICAgICAgXG4gICAgICAvLyBBdXRvLXN3aXRjaCBiYWNrIHRvIHNlbGVjdCBtb2RlIGFmdGVyIGNyZWF0aW5nIGEgc2hhcGVcbiAgICAgIHNldEN1cnJlbnRUb29sKCdzZWxlY3QnKTtcbiAgICB9LFxuICAgIFtjdXJyZW50VG9vbCwgcHJvamVjdCwgbm9kZXMsIHNldE5vZGVzLCBzYXZlVG9IaXN0b3J5LCBzZXRDdXJyZW50VG9vbCwgZ2VuZXJhdGVOb2RlSWRdXG4gICk7XG5cbiAgY29uc3Qgb25TZWxlY3Rpb25DaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAocGFyYW1zOiBPblNlbGVjdGlvbkNoYW5nZVBhcmFtcykgPT4ge1xuICAgICAgc2V0U2VsZWN0ZWROb2RlcyhwYXJhbXMubm9kZXMpO1xuICAgIH0sXG4gICAgW3NldFNlbGVjdGVkTm9kZXNdXG4gICk7XG5cbiAgY29uc3Qgb25Ob2RlQ2xpY2sgPSB1c2VDYWxsYmFjayhcbiAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQsIG5vZGU6IE5vZGUpID0+IHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgLy8gQWxsb3cgdGhlIG5vZGUncyBvd24gY2xpY2sgaGFuZGxlciB0byBtYW5hZ2UgcG9wdXAgc3RhdGVcbiAgICB9LFxuICAgIFtdXG4gICk7XG5cbiAgY29uc3Qgb25FZGdlQ2xpY2sgPSB1c2VDYWxsYmFjayhcbiAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQsIGVkZ2U6IEVkZ2UpID0+IHtcbiAgICB9LFxuICAgIFtdXG4gICk7XG5cbiAgY29uc3Qgb25Ob2RlRHJhZ1N0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2F2ZVRvSGlzdG9yeSgpO1xuICB9LCBbc2F2ZVRvSGlzdG9yeV0pO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBoYW5kbGUgcG9zaXRpb25zIGJhc2VkIG9uIG5vZGUgcmVsYXRpb25zaGlwc1xuICBjb25zdCB1cGRhdGVIYW5kbGVQb3NpdGlvbnMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZE5vZGVzID0gbm9kZXMubWFwKG5vZGUgPT4ge1xuICAgICAgLy8gRmluZCBhbGwgZWRnZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZVxuICAgICAgY29uc3QgY29ubmVjdGVkRWRnZXMgPSBlZGdlcy5maWx0ZXIoZWRnZSA9PiBcbiAgICAgICAgZWRnZS5zb3VyY2UgPT09IG5vZGUuaWQgfHwgZWRnZS50YXJnZXQgPT09IG5vZGUuaWRcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBvcHRpbWFsIGhhbmRsZSBwb3NpdGlvbnMgYmFzZWQgb24gY29ubmVjdGVkIG5vZGVzXG4gICAgICBjb25zdCBoYW5kbGVQb3NpdGlvbnMgPSBjYWxjdWxhdGVPcHRpbWFsSGFuZGxlcyhub2RlLCBjb25uZWN0ZWRFZGdlcywgbm9kZXMpO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4ubm9kZS5kYXRhLFxuICAgICAgICAgIGhhbmRsZVBvc2l0aW9uc1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIHNldE5vZGVzKHVwZGF0ZWROb2Rlcyk7XG4gIH0sIFtub2RlcywgZWRnZXMsIHNldE5vZGVzXSk7XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBvcHRpbWFsIGhhbmRsZSBwb3NpdGlvbnNcbiAgY29uc3QgY2FsY3VsYXRlT3B0aW1hbEhhbmRsZXMgPSB1c2VDYWxsYmFjaygobm9kZTogTm9kZSwgY29ubmVjdGVkRWRnZXM6IEVkZ2VbXSwgYWxsTm9kZXM6IE5vZGVbXSkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXM6IGFueSA9IHt9O1xuICAgIFxuICAgIGNvbm5lY3RlZEVkZ2VzLmZvckVhY2goZWRnZSA9PiB7XG4gICAgICBjb25zdCBpc1NvdXJjZSA9IGVkZ2Uuc291cmNlID09PSBub2RlLmlkO1xuICAgICAgY29uc3QgY29ubmVjdGVkTm9kZUlkID0gaXNTb3VyY2UgPyBlZGdlLnRhcmdldCA6IGVkZ2Uuc291cmNlO1xuICAgICAgY29uc3QgY29ubmVjdGVkTm9kZSA9IGFsbE5vZGVzLmZpbmQobiA9PiBuLmlkID09PSBjb25uZWN0ZWROb2RlSWQpO1xuICAgICAgXG4gICAgICBpZiAoY29ubmVjdGVkTm9kZSkge1xuICAgICAgICBjb25zdCBkeCA9IGNvbm5lY3RlZE5vZGUucG9zaXRpb24ueCAtIG5vZGUucG9zaXRpb24ueDtcbiAgICAgICAgY29uc3QgZHkgPSBjb25uZWN0ZWROb2RlLnBvc2l0aW9uLnkgLSBub2RlLnBvc2l0aW9uLnk7XG4gICAgICAgIFxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGJlc3QgaGFuZGxlIHBvc2l0aW9uIGJhc2VkIG9uIHJlbGF0aXZlIHBvc2l0aW9uXG4gICAgICAgIGxldCBwb3NpdGlvbjtcbiAgICAgICAgaWYgKE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgICAgIC8vIEhvcml6b250YWwgY29ubmVjdGlvbiBpcyBzdHJvbmdlclxuICAgICAgICAgIHBvc2l0aW9uID0gZHggPiAwID8gUG9zaXRpb24uUmlnaHQgOiBQb3NpdGlvbi5MZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFZlcnRpY2FsIGNvbm5lY3Rpb24gaXMgc3Ryb25nZXJcbiAgICAgICAgICBwb3NpdGlvbiA9IGR5ID4gMCA/IFBvc2l0aW9uLkJvdHRvbSA6IFBvc2l0aW9uLlRvcDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgaGFuZGxlVHlwZSA9IGlzU291cmNlID8gJ3NvdXJjZScgOiAndGFyZ2V0JztcbiAgICAgICAgaGFuZGxlc1tgJHtoYW5kbGVUeXBlfS0ke2VkZ2UuaWR9YF0gPSBwb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gaGFuZGxlcztcbiAgfSwgW10pO1xuICAvLyBDdXN0b20gbm9kZSB0eXBlcyB3aXRoIGxheW91dC1hd2FyZSBoYW5kbGVzXG4gIGNvbnN0IG5vZGVUeXBlcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjdXN0b206IChwcm9wczogYW55KSA9PiA8Q3VzdG9tTm9kZSB7Li4ucHJvcHN9IC8+LFxuICB9KSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsXCIgcmVmPXtyZWFjdEZsb3dXcmFwcGVyfT5cbiAgICAgIDxSZWFjdEZsb3dcbiAgICAgICAgbm9kZXM9e25vZGVzfVxuICAgICAgICBlZGdlcz17ZWRnZXN9XG4gICAgICAgIG9uTm9kZXNDaGFuZ2U9e29uTm9kZXNDaGFuZ2V9XG4gICAgICAgIG9uRWRnZXNDaGFuZ2U9e29uRWRnZXNDaGFuZ2V9XG4gICAgICAgIG9uQ29ubmVjdD17b25Db25uZWN0fVxuICAgICAgICBvblBhbmVDbGljaz17b25QYW5lQ2xpY2t9XG4gICAgICAgIG9uTm9kZUNsaWNrPXtvbk5vZGVDbGlja31cbiAgICAgICAgb25FZGdlQ2xpY2s9e29uRWRnZUNsaWNrfVxuICAgICAgICBvbk5vZGVEcmFnU3RvcD17b25Ob2RlRHJhZ1N0b3B9XG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlPXtvblNlbGVjdGlvbkNoYW5nZX1cbiAgICAgICAgbm9kZVR5cGVzPXtub2RlVHlwZXN9XG4gICAgICAgIGZpdFZpZXdcbiAgICAgICAgY2xhc3NOYW1lPVwiYmctZ3JheS01MCBkYXJrOmJnLVsjMGEwYTBhXVwiXG4gICAgICAgIG5vZGVzRHJhZ2dhYmxlPXtjdXJyZW50VG9vbCA9PT0gJ3NlbGVjdCd9XG4gICAgICAgIG5vZGVzQ29ubmVjdGFibGU9e2N1cnJlbnRUb29sID09PSAnc2VsZWN0J31cbiAgICAgICAgZWxlbWVudHNTZWxlY3RhYmxlPXtjdXJyZW50VG9vbCA9PT0gJ3NlbGVjdCd9XG4gICAgICAgIHBhbk9uRHJhZz17Y3VycmVudFRvb2wgPT09ICdzZWxlY3QnfVxuICAgICAgICB6b29tT25TY3JvbGw9e2N1cnJlbnRUb29sID09PSAnc2VsZWN0J31cbiAgICAgICAgLy8gY29ubmVjdGlvbk1vZGU9XCJsb29zZVwiXG4gICAgICA+XG4gICAgICAgIDxDb250cm9scyBcbiAgICAgICAgICBwb3NpdGlvbj1cImJvdHRvbS1yaWdodFwiIFxuICAgICAgICAgIGNsYXNzTmFtZT1cImJnLXdoaXRlIGRhcms6YmctWyMxMDEwMTBdIGJvcmRlciBib3JkZXItZ3JheS0yMDAgZGFyazpib3JkZXItZ3JheS03MDBcIlxuICAgICAgICAvPlxuICAgICAgPC9SZWFjdEZsb3c+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDYW52YXMoKSB7XG4gIHJldHVybiAoXG4gICAgPFJlYWN0Rmxvd1Byb3ZpZGVyPlxuICAgICAgPFRvb2xiYXIgLz5cbiAgICAgIDxGbG93Q2FudmFzIC8+XG4gICAgPC9SZWFjdEZsb3dQcm92aWRlcj5cbiAgKTtcbn0iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwiUmVhY3RGbG93IiwiUmVhY3RGbG93UHJvdmlkZXIiLCJhZGRFZGdlIiwiYXBwbHlOb2RlQ2hhbmdlcyIsImFwcGx5RWRnZUNoYW5nZXMiLCJDb250cm9scyIsInVzZVJlYWN0RmxvdyIsIk1hcmtlclR5cGUiLCJ1c2VBcHBTdG9yZSIsIkN1c3RvbU5vZGUiLCJUb29sYmFyIiwibm9kZVR5cGVzIiwiY3VzdG9tIiwiRmxvd0NhbnZhcyIsInJlYWN0Rmxvd1dyYXBwZXIiLCJjdXJyZW50VG9vbCIsInNldEN1cnJlbnRUb29sIiwibm9kZXMiLCJlZGdlcyIsInNldE5vZGVzIiwic2V0RWRnZXMiLCJzYXZlVG9IaXN0b3J5IiwidW5kbyIsInNlbGVjdGVkTm9kZXMiLCJzZXRTZWxlY3RlZE5vZGVzIiwiY2xpcGJvYXJkIiwic2V0Q2xpcGJvYXJkIiwicHJvamVjdCIsImdlbmVyYXRlTm9kZUlkIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJnZW5lcmF0ZUVkZ2VJZCIsImhhbmRsZUtleURvd24iLCJldmVudCIsImN0cmxLZXkiLCJrZXkiLCJwcmV2ZW50RGVmYXVsdCIsImxlbmd0aCIsInNlbGVjdGVkTm9kZUlkcyIsIm1hcCIsIm5vZGUiLCJpZCIsInNlbGVjdGVkRWRnZXMiLCJmaWx0ZXIiLCJlZGdlIiwiaW5jbHVkZXMiLCJzb3VyY2UiLCJ0YXJnZXQiLCJub2RlSWRNYXAiLCJNYXAiLCJuZXdOb2RlcyIsIm5ld0lkIiwic2V0IiwicG9zaXRpb24iLCJ4IiwieSIsInNlbGVjdGVkIiwibmV3RWRnZXMiLCJnZXQiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25Ob2Rlc0NoYW5nZSIsImNoYW5nZXMiLCJvbkVkZ2VzQ2hhbmdlIiwib25Db25uZWN0IiwicGFyYW1zIiwibmV3RWRnZSIsInN0eWxlIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJtYXJrZXJFbmQiLCJ0eXBlIiwiQXJyb3dDbG9zZWQiLCJ3aWR0aCIsImhlaWdodCIsImNvbG9yIiwiYW5pbWF0ZWQiLCJzZXRUaW1lb3V0IiwidXBkYXRlSGFuZGxlUG9zaXRpb25zIiwib25QYW5lQ2xpY2siLCJzdGF0ZSIsImdldFN0YXRlIiwic2V0RWRpdGluZ05vZGVJZCIsInBvcHVwQ2xvc2VFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImJvdW5kcyIsImN1cnJlbnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRYIiwibGVmdCIsImNsaWVudFkiLCJ0b3AiLCJuZXdOb2RlIiwiZGF0YSIsImxhYmVsIiwibm9kZVR5cGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJ1bmRlZmluZWQiLCJ0ZXh0Q29sb3IiLCJib3JkZXJTdHlsZSIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwib25Ob2RlQ2xpY2siLCJzdG9wUHJvcGFnYXRpb24iLCJvbkVkZ2VDbGljayIsIm9uTm9kZURyYWdTdG9wIiwidXBkYXRlZE5vZGVzIiwiY29ubmVjdGVkRWRnZXMiLCJoYW5kbGVQb3NpdGlvbnMiLCJjYWxjdWxhdGVPcHRpbWFsSGFuZGxlcyIsImFsbE5vZGVzIiwiaGFuZGxlcyIsImZvckVhY2giLCJpc1NvdXJjZSIsImNvbm5lY3RlZE5vZGVJZCIsImNvbm5lY3RlZE5vZGUiLCJmaW5kIiwibiIsImR4IiwiZHkiLCJhYnMiLCJQb3NpdGlvbiIsIlJpZ2h0IiwiTGVmdCIsIkJvdHRvbSIsIlRvcCIsImhhbmRsZVR5cGUiLCJwcm9wcyIsImRpdiIsImNsYXNzTmFtZSIsInJlZiIsImZpdFZpZXciLCJub2Rlc0RyYWdnYWJsZSIsIm5vZGVzQ29ubmVjdGFibGUiLCJlbGVtZW50c1NlbGVjdGFibGUiLCJwYW5PbkRyYWciLCJ6b29tT25TY3JvbGwiLCJDYW52YXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/canvas.tsx\n"));

/***/ })

});